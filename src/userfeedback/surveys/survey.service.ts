import { Injectable, NotFoundException } from "@nestjs/common";
import { Survey, SurveyStatus } from "src/entities/survey.entity";
import { SurveySection } from "src/entities/survey_section.entity";
import { Choice } from "src/entities/uf_choice.entity";
import { Question } from "src/entities/uf_question.entity";
import { QuestionItemDto, QuestionsDto, SurveyDto } from "./survey.dto";
import { isUUID } from "class-validator";

// {id: int, name: string}
@Injectable()
export class SurveyService {
  async createOrUpdate(dto: SurveyDto): Promise<Survey> {
    const survey = dto.id != null ? await this.findById(dto.id) : new Survey();
    const isNew = dto.id != null;

    console.log(isNew);

    survey.name ??= dto.name;
    survey.project_code ??= dto.project_code;
    survey.description ??= dto.description;
    survey.status ??= dto.status ?? SurveyStatus.draft;
    await survey.save();

    // Create default section
    if (!isNew) {
      const section = new SurveySection();
      section.name = "Untitled Section";
      section.survey_id = survey.id;
      await section.save();
    }

    return this.findById(survey.id);
  }

  async findById(id: number) {
    const survey = await Survey.findOne({
      where: { id },
      relations: {
        deployment: true,
        sections: true,
        questions: { choices: { sub_options: true } },
      },
    });

    if (survey == null) {
      throw new NotFoundException("Survey not found");
    }

    return survey;
  }

  async saveQuestions(dto: QuestionsDto, surveyId: number) {
    const survey = await this.findById(surveyId);
    dto.sections ??= [];
    dto.questions ??= [];

    // Fetch existing questions in the database
    const existingQuestions = await Question.find({
        where: { survey_id: survey.id }
    });

    // Create a Set of question IDs from the new data
    const newQuestionIds = new Set(dto.questions.map(q => q._id));


    // Identify questions that are missing in the new list (i.e., they were removed)
    const removedQuestions = existingQuestions.filter(q => !newQuestionIds.has(q._id));


    // Delete removed questions from the database
    for (const removedQuestion of removedQuestions) {

        await removedQuestion.remove();
    }

    // Handle sections
    for (let i = 0; i < dto.sections.length; i++) {
        const section_dto = dto.sections[i];

        // Delete removed sections from db
        if (section_dto.is_deleted === true) {
            await SurveySection.findOne({
                where: { _id: section_dto._id, survey_id: survey.id },
            }).then((section) => section?.softRemove());

            dto.sections.splice(i, 1); // Remove from dto
            continue;
        }

        const created = await this.createSection(
            { id: section_dto._id, name: section_dto.name },
            surveyId
        );

        dto.sections[i] = section_dto;
        dto.questions = dto.questions.map(q => {
            if (q.section_id === created._id || q.section_id === created.id) {
                q.section_id = created.id;
            }
            return q;
        });
    }

    // Create/update questions
    for (let i = 0; i < dto.questions.length; i++) {
        const question_dto = dto.questions[i];

        question_dto.order = i;
        await this.createQuestion(surveyId, question_dto).then((q) => q.id);
    }

    return this.findById(surveyId);
}


  private async createQuestion(survey_id: number, dto: QuestionItemDto) {
    const question = (await Question.findOne({ where: { _id: dto._id } })) ?? new Question();

    question.question_label = dto.question_label ?? "Untitled Question";
    question.survey_id = survey_id;
    question.type = dto.type ?? "text";
    question.order = dto.order ?? 0;
    question.required = dto.required ?? true;
    question.parent_id = dto.parent_id;
    question._id = dto._id;
    question.conditions = dto.conditions;
    question.section_id = dto.section_id as number;

    await question.save();

    // Save options
    await this._create_or_update_choices({
      question: question,
      dto: dto.choices ?? [],
    });

    return question;
  }

  async _create_or_update_choices(opts: {
    question: Question;
    dto: Record<string, any>[];
    parent_choice_id?: number;
  }) {
    const { question, dto, parent_choice_id } = opts;

    for (let i = 0; i < dto.length; i++) {
      const option = dto[i];
      const option_id = option.choice_id;

      if ((option.is_deleted ?? false) && Number.isInteger(option_id)) {
        await Choice.delete({ choice_id: option_id });
        continue;
      }

      let choice = new Choice()
      if (!isUUID(option_id)) { // ids generated by the frontend is a uuid string
        choice =
          (await Choice.findOne({ where: { choice_id: option_id } })) ??
          new Choice();
      }

      choice.value = option.value ?? "";
      choice.is_other = option.is_other ?? false;
      choice.question_id = question.id;
      choice.parent_id = parent_choice_id;

      // TODO: make the following nullable
      choice.choice_list = choice.value;
      choice.choice_label = choice.value;

      choice.order = option.order ?? i + 1;
      await choice.save();

      // Save sub options
      await this._create_or_update_choices({
        question: question,
        dto: option.sub_options ?? [],
        parent_choice_id: choice.choice_id,
      });
    }

    return question;
  }

  private async createSection(
    dto: { id: string; name?: string },
    surveyId: number,
  ) {
    const sectionId = dto.id;
    let section = new SurveySection();

    section = (await SurveySection.findOne({ where: { _id: sectionId } })) ??
      new SurveySection();

    section.name ??= dto.name ?? "Untitled Section";
    section.survey_id ??= surveyId;
    section._id ??= sectionId;
    await section.save();

    return section;
  }
}
